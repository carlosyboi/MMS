local a={FlagName="Flag",PartsName="Parts",SafeText="failed to fetch text",Colors={Mine=Color3.fromRGB(205,142,100),PredictedMine=Color3.fromRGB(255,60,60),PredictedSafe=Color3.fromRGB(60,255,60)},Spacing=5,Origin=Vector3.new(0,70,0),Delays={Logic=0.2,Render=0.01},TotalMines=99,UseMineBudget=false,MineDensity=0.207,RecommendBestMove=true,GuessPolicy={UseEntropyTieBreak=true,FallbackRisk=0.5,RiskEpsilon=1e-9,MaxEntropyCandidates=10},Lookahead={Enabled=true,MaxVars=22,MaxCandidates=6}}if not getgenv then getgenv=function()return _G end end;getgenv().MS_RUN=true;local b={}local c={}for d=0,100 do local e=d/100;local f=0.33*(1-e)b[d]=Color3.fromHSV(f,1,1)c[d]=tostring(d).."%"end;local d={}function d.Wait(e)wait(e)end;function d.CalculateDistance(e,f)local g=e.X-f.X;local h=e.Y-f.Y;local i=e.Z-f.Z;return math.sqrt(g*g+h*h+i*i)end;function d.GetRefPosition()local e,f=pcall(function()local e=game:GetService"Players"local f=e.LocalPlayer;if f and f.Character then local g=f.Character:FindFirstChild"HumanoidRootPart"if g then return g.Position end end;return nil end)if e and f then return f end;if workspace.CurrentCamera then return workspace.CurrentCamera.Position end;return Vector3.new(0,0,0)end;function d.Clamp(e,f,g)if e<f then return f end;if e>g then return g end;return e end;function d.SafeGet(e,f)if not e or not e.Parent then return nil end;local g,h=pcall(function()return e[f]end)if g then return h end;return nil end;local e=-math.huge;local function j(f,g)if f==e then return g end;if g==e then return f end;if f<g then f,g=g,f end;return f+math.log(1+math.exp(g-f))end;local f={[0]=0}local function k(g)for h=(f._max or 0)+1,g do f[h]=(f[h-1]or 0)+math.log(h)end;f._max=math.max(f._max or 0,g)end;local function l(g,h)if h<0 or h>g then return e end;k(g)return(f[g]or 0)-(f[h]or 0)-(f[g-h]or 0)end;local function m(g,h,i)local n={}for o=0,i do n[o]=e end;for o=0,i do if g[o]~=e then for p=0,math.min(i-o,#h-1)do local q=h[p+1]if q~=e then n[o+p]=j(n[o+p],g[o]+q)end end end end;return n end;local function r(g,h,i,n)local o=e;for p=0,i do local q=g[p+1]local s=h[i-p]if q and q~=e and s and s~=e then o=j(o,q+s)end end;if o==e then return 0 end;return math.exp(o-n)end;local g={ActiveMarkers={},Best={ring=nil,text=nil}}function g.CreateMarker(h,i)local n=Drawing.new"Square"n.Color=i;n.Thickness=2;n.Filled=true;n.Transparency=0.6;n.Visible=true;n.ZIndex=2;n.Size=Vector2.new(20,20)local o=Drawing.new"Text"o.Text=""o.Color=Color3.new(1,1,1)o.Center=true;o.Outline=true;o.Size=16;o.Visible=false;o.ZIndex=3;local p={box=n,text=o,storedPos=nil,hasText=false,_lastVisible=false,_lastSX=nil,_lastSY=nil,_lastSize=nil,_lastTextVisible=false}g.ActiveMarkers[h]=p;return p end;function g.UpdateMarker(h,i,n,o)local p=g.ActiveMarkers[h]if not p then p=g.CreateMarker(h,i)end;p.box.Color=i;if o then p.storedPos=o end;if n then p.text.Text=n;p.hasText=true else p.text.Text=""p.hasText=false end end;function g.RemoveMarker(h)local i=g.ActiveMarkers[h]if i then pcall(function()i.box:Remove()end)pcall(function()i.text:Remove()end)g.ActiveMarkers[h]=nil end end;function g.InitBestMarker()if g.Best.ring then return end;local h=Drawing.new"Circle"h.Filled=false;h.Thickness=2;h.NumSides=32;h.Visible=false;h.Color=Color3.fromRGB(0,255,255)h.Radius=18;local i=Drawing.new"Text"i.Center=true;i.Outline=true;i.Text="BEST"i.Visible=false;i.Color=Color3.fromRGB(0,255,255)g.Best.ring=h;g.Best.text=i;g.Best._lastVisible=false;g.Best._lastSX=nil;g.Best._lastSY=nil end;function g.ClearAll()for h,i in pairs(g.ActiveMarkers)do pcall(function()i.box:Remove()end)pcall(function()i.text:Remove()end)end;g.ActiveMarkers={}if g.Best.ring then g.Best.ring:Remove()end;if g.Best.text then g.Best.text:Remove()end;g.Best={ring=nil,text=nil}end;local h={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}local i={Tiles={},Map={},BestMove=nil}function i.GetGridCoordinates(n)if not n then return nil end;local o=math.floor((n.X-a.Origin.X)/a.Spacing+0.5)local p=math.floor((n.Z-a.Origin.Z)/a.Spacing+0.5)return o.."|"..p,o,p end;function i.AnalyzeTilePart(n)if not n or not n.Parent then return"deleted",nil end;local o=n:FindFirstChild"NumberGui"if o then local p=o:FindFirstChild"TextLabel"if p then local q=d.SafeGet(p,"Text")if q then if q==a.SafeText then return"empty",0 end;local s=tonumber(q)if s then return"number",s end;if q==""or q==" "then return"number",0 end end end end;local p=d.SafeGet(n,"Color")if p and p==a.Colors.Mine then return"mine",nil end;return"unknown",nil end;function i.RegisterTile(n)local o=d.SafeGet(n,"Position")if not o then return end;local p,q,s=i.GetGridCoordinates(o)local t=i.Map[p]if t then if t.part~=n then g.RemoveMarker(t.part)t.part=n;t.storedPos=o;t.visKey=nil end;t.gridX=q;t.gridZ=s;local u,v=i.AnalyzeTilePart(n)if u~="deleted"then t.type=u;t.number=v end;t.predicted=false;t.probability=nil;return end;local u,v=i.AnalyzeTilePart(n)local w={part=n,storedPos=o,gridX=q,gridZ=s,type=u,number=v,predicted=false,probability=nil,visKey=nil}table.insert(i.Tiles,w)i.Map[p]=w end;function i.GetNeighbors(n)local o={}local p=i.Map;local q,s=n.gridX,n.gridZ;for t,u in ipairs(h)do local v=q+u[1].."|"..s+u[2]local w=p[v]if w then table.insert(o,w)end end;return o end;local n={}local o,p={},{}local function x(q)for s=#q,1,-1 do q[s]=nil end end;local function y(q)for s in pairs(q)do q[s]=nil end end;local function z()local q=o[#o]o[#o]=nil;local s=p[#p]p[#p]=nil;if not q then q={}end;if not s then s={}end;return q,s end;local function A(q,s)x(q)y(s)o[#o+1]=q;p[#p+1]=s end;local function B(q,s)local t={}local u={}local v={}for w,C in ipairs(s)do if not t[C]then t[C]=true;v[#v+1]=C end end;local w={}local C={}local D=1;while D<=#v do local E=v[D]D=D+1;w[#w+1]=E;local F=q.varToEqIndex[E]if F then for G,H in ipairs(F)do if not u[H]then u[H]=true;local I=q.equations[H]C[#C+1]=I;for J,K in ipairs(I.vars)do if not t[K]then t[K]=true;v[#v+1]=K end end end end end end;return w,C end;local function L(q,s,t)local u={}local v={}for w=1,#q do local C=q[w]u[C]=w;v[w]=C end;local w=#q;local C={}for D,E in ipairs(s)do local F={}for G,H in ipairs(E.vars)do F[#F+1]=u[H]end;C[#C+1]={needed=E.needed,vars=F}end;if t then for D,E in ipairs(t)do C[#C+1]=E end end;local D={}for E=1,w do D[E]={}end;for E,F in ipairs(C)do for G,H in ipairs(F.vars)do D[H][#D[H]+1]=E end end;local E={}local F={}local G={}for H,I in ipairs(C)do F[H]=0;G[H]=#I.vars end;local function M(H,I,J)if not I[J]then I[J]=true;H[#H+1]=J end end;local function N(H,I,J,K,O)if E[H]~=nil then return E[H]==I end;E[H]=I;J[#J+1]={v=H,val=I}for P,Q in ipairs(D[H])do G[Q]=G[Q]-1;F[Q]=F[Q]+I;M(K,O,Q)end;return true end;local function R(H,I)while#H>I do local J=H[#H]H[#H]=nil;local K=J.v;local O=J.val;E[K]=nil;for P,Q in ipairs(D[K])do G[Q]=G[Q]+1;F[Q]=F[Q]-O end end end;local function S(H,I,J)local K=1;while K<=#I do local O=I[K]K=K+1;J[O]=false;local P=C[O]local Q=P.needed;local T=F[O]local U=G[O]if T>Q then return false end;if T+U<Q then return false end;if U>0 then if T==Q then for V,W in ipairs(P.vars)do if E[W]==nil then if not N(W,0,H,I,J)then return false end end end elseif T+U==Q then for V,W in ipairs(P.vars)do if E[W]==nil then if not N(W,1,H,I,J)then return false end end end end else if T~=Q then return false end end end;return true end;local function X()for H=1,w do if E[H]==nil then return H end end;return nil end;local H=0;local function Y(I)local J=X()if not J then H=H+1;return end;do local K=#I;local O,P=z()if N(J,0,I,O,P)and S(I,O,P)then Y(I)end;A(O,P)R(I,K)end;do local K=#I;local O,P=z()if N(J,1,I,O,P)and S(I,O,P)then Y(I)end;A(O,P)R(I,K)end end;do local I={}local J,K={},{}for O=1,#C do M(J,K,O)end;if S(I,J,K)then Y(I)end end;return H,u end;function n.ScoreTileLookahead(q)local s=n._LastTankSystem;if not(a.Lookahead.Enabled and s and s.unknownMap)then return nil end;local t=s.unknownMap[q]if not t then return nil end;local u=0;local v={}local w=i.GetNeighbors(q)for C,D in ipairs(w)do if D.type=="mine"or D.predicted=="mine"then u=u+1 elseif D.type=="unknown"and D.predicted~="safe"then local E=s.unknownMap[D]if not E then return nil end;v[#v+1]=E end end;local C={t}for D=1,#v do C[#C+1]=v[D]end;local D,E=B(s,C)if#D>a.Lookahead.MaxVars then return nil end;local F=0;local G={}for H=0,#v do local I={}I[#I+1]={needed=0,vars={0}}I[#I+1]={needed=H,vars={}}local J,K=L(D,E,nil)if J==0 then return nil end;local O=K[t]if not O then return nil end;I[1]={needed=0,vars={O}}local P={}for Q=1,#v do P[#P+1]=K[v[Q]]end;I[2]={needed=H,vars=P}local Q=L(D,E,I)G[H]=Q;F=F+Q end;if F<=0 then return nil end;local H=math.log(F)local I=0;for J=0,#v do local K=G[J]or 0;if K>0 then local O=K/F;I=I+O*math.log(K)end end;local J=H-I;local K=q.probability or 0.5;if q.predicted=="safe"then K=0 end;if q.predicted=="mine"then K=1 end;return(1-K)*J end;local function Z(q)if q.predicted=="mine"then return 1 end;if q.predicted=="safe"then return 0 end;if q.probability~=nil then return q.probability end;return a.GuessPolicy.FallbackRisk end;local function _(q)local s=0;for t=1,#q do local u=q[t]if u and u>0 then s=s-u*math.log(u)end end;return s end;local function a0(q)local s=i.GetNeighbors(q)local t=0;local u={}for v,w in ipairs(s)do if w.type=="mine"or w.predicted=="mine"then t=t+1 elseif w.type=="unknown"and w.predicted~="safe"then u[#u+1]=Z(w)end end;local v={[0]=1}for w=1,#u do local C=u[w]local D={}for E,F in pairs(v)do D[E]=(D[E]or 0)+F*(1-C)D[E+1]=(D[E+1]or 0)+F*C end;v=D end;local w={}for C=0,8 do w[C+1]=0 end;for C,D in pairs(v)do local E=C+t;if E>=0 and E<=8 then w[E+1]=w[E+1]+D end end;local C=0;for D=1,#w do C=C+w[D]end;if C>0 then for D=1,#w do w[D]=w[D]/C end end;return w end;function n.PickBestMove()local q=2;local s={}for t,u in ipairs(i.Tiles)do if u.type=="unknown"and u.predicted~="mine"then local v=u.probability or 0.5;if u.predicted=="safe"then v=0 end;if v<q-a.GuessPolicy.RiskEpsilon then q=v;s={u}elseif math.abs(v-q)<=a.GuessPolicy.RiskEpsilon then s[#s+1]=u end end end;if#s==0 then return nil,nil end;local t=d.GetRefPosition()if#s>1 and t then table.sort(s,function(u,v)local w=u.storedPos;local C=v.storedPos;if not w then return false end;if not C then return true end;return d.CalculateDistance(w,t)<d.CalculateDistance(C,t)end)end;if q==0 then return s[1],0 end;local u=s[1]local v=-1;local w=math.min(#s,a.Lookahead.MaxCandidates)for C=1,w do local D=s[C]local E=n.ScoreTileLookahead(D)if not E and a.GuessPolicy.UseEntropyTieBreak then local F=a0(D)local G=D.probability or 0.5;E=(1-G)*_(F)end;if not E then local F=0;local G=i.GetNeighbors(D)for H,I in ipairs(G)do if I.type=="unknown"and I.predicted~="mine"then F=F+1 end end;E=F*0.01 end;if E>v then v=E;u=D end end;return u,q end;function n.GetState(q)local s=i.GetNeighbors(q)local t={}local u=0;for v,w in ipairs(s)do if w.type=="mine"or w.predicted=="mine"then u=u+1 elseif w.type=="unknown"and w.predicted~="safe"then table.insert(t,w)end end;return t,u end;function n.RunTrivial()local q=false;for s,t in ipairs(i.Tiles)do if t.type=="number"and t.number then local u,v=n.GetState(t)local w=t.number-v;local C=#u;if C>0 then if w==0 then for D,E in ipairs(u)do if E.predicted~="safe"then E.predicted="safe"q=true end end elseif w==C then for D,E in ipairs(u)do if E.predicted~="mine"then E.predicted="mine"q=true end end end end end end;return q end;local function a1(q)table.sort(q)local s={}local t;for u=1,#q do local v=q[u]if v~=t then s[#s+1]=v;t=v end end;return s end;local function a2(q)local s={}for t=1,#q do s[t]=tostring(q[t])end;return table.concat(s,",")end;local function a3(q)return tostring(q.needed)..":"..a2(q.vars)end;local function a4(q,s)local t,u=1,1;while t<=#q and u<=#s do local v,w=q[t],s[u]if v==w then t=t+1;u=u+1 elseif v>w then u=u+1 else return false end end;return t>#q end;local function a5(q,s)local t={}local u,v=1,1;while u<=#q do local w,C=q[u],s[v]if C==nil then t[#t+1]=w;u=u+1 elseif w==C then u=u+1;v=v+1 elseif w<C then t[#t+1]=w;u=u+1 else v=v+1 end end;return t end;local function a6(q)local s={}local t={}for u,v in ipairs(q)do local w=a1(v.vars)local C=v.needed;if C<0 or C>#w then return nil,"contradiction"end;local D=a2(w)local E=t[D]if E==nil then t[D]=C;s[#s+1]={needed=C,vars=w}else if E~=C then return nil,"contradiction"end end end;local u={}for v,w in ipairs(s)do u[a3(w)]=true end;local v=256;local w=true;while w do w=false;for C=1,#s do local D=s[C]for E=1,#s do if C~=E then local F=s[E]if#D.vars>0 and#D.vars<#F.vars then if a4(D.vars,F.vars)then local G=F.needed-D.needed;local H=a5(F.vars,D.vars)if G<0 or G>#H then return nil,"contradiction"end;if#H==0 then if G~=0 then return nil,"contradiction"end else local I={needed=G,vars=H}local J=a3(I)if not u[J]then u[J]=true;s[#s+1]=I;w=true;if#s>v then return s,"cap_hit"end end end end end end end end end;return s,"ok"end;function n.RunTank()local q=false;local s=0;for t,u in ipairs(i.Tiles)do if u.type=="mine"or u.predicted=="mine"and u.probability==1 then s=s+1 end end;local t=a.TotalMines-s;if t<0 then t=0 end;local u={}local v={}local w={}for C,D in ipairs(i.Tiles)do if D.type=="number"and D.number then local E,F=n.GetState(D)local G=D.number-F;if#E>0 and G>=0 then local H={}for I,J in ipairs(E)do if not u[J]then table.insert(v,J)u[J]=#v end;table.insert(H,u[J])end;table.insert(w,{needed=G,vars=H})end end end;if#v==0 then return false end;local C={}if a.UseMineBudget then for D,E in ipairs(i.Tiles)do if E.type=="unknown"and E.predicted~="safe"and not u[E]then table.insert(C,E)end end end;local D={}for E=1,#v do D[E]={}end;for E,F in ipairs(w)do for G,H in ipairs(F.vars)do table.insert(D[H],E)end end;local E={}local F={}for G=1,#v do if not E[G]then local H={}local I={}local J={G}E[G]=true;local K={}local O=1;while O<=#J do local P=J[O]O=O+1;table.insert(H,P)for Q,T in ipairs(D[P])do if not K[T]then K[T]=true;table.insert(I,w[T])for U,V in ipairs(w[T].vars)do if not E[V]then E[V]=true;table.insert(J,V)end end end end end;table.insert(F,{vars=H,eqs=I})end end;local G={}if not a.UseMineBudget then local H=a.MineDensity;local I=H/(1-H)for J=0,50 do G[J]=math.pow(I,J)end end;for H,I in ipairs(F)do if#I.vars<=16 then local J={}do for K=1,#I.vars do J[K]=I.vars[K]end;local K={}for O=1,#J do K[J[O]]=0 end;for O,P in ipairs(I.eqs)do for Q,T in ipairs(P.vars)do if K[T]~=nil then K[T]=K[T]+1 end end end;table.sort(J,function(O,P)return(K[O]or 0)>(K[P]or 0)end)end;I.orderedVars=J;local K={}local O={}for P,Q in ipairs(J)do K[Q]=P;O[P]=Q end;local P=#J;local Q={}for T,U in ipairs(I.eqs)do local V={}for W,a7 in ipairs(U.vars)do V[#V+1]=K[a7]end;Q[#Q+1]={needed=U.needed,vars=V}end;local T;Q,T=a6(Q)if Q then local U={}for V=1,P do U[V]={}end;for V,W in ipairs(Q)do for a7,a8 in ipairs(W.vars)do U[a8][#U[a8]+1]=V end end;local V={}for W=1,P do V[W]=#U[W]end;local W={}local a7={}local a8={}for a9,aa in ipairs(Q)do a7[a9]=0;a8[a9]=#aa.vars end;I.solutionData={ways={},hits={}}for a9=1,P do I.solutionData.hits[a9]={}end;local a9=0;local aa=0;local function M(ab,ac,ad)if not ac[ad]then ac[ad]=true;ab[#ab+1]=ad end end;local function N(ab,ac,ad,ae,af)if W[ab]~=nil then return W[ab]==ac end;W[ab]=ac;ad[#ad+1]={v=ab,val=ac}for ag,ah in ipairs(U[ab])do a8[ah]=a8[ah]-1;a7[ah]=a7[ah]+ac;M(ae,af,ah)end;return true end;local function R(ab,ac)while#ab>ac do local ad=ab[#ab]ab[#ab]=nil;local ae,af=ad.v,ad.val;W[ae]=nil;for ag,ah in ipairs(U[ae])do a8[ah]=a8[ah]+1;a7[ah]=a7[ah]-af end end end;local function S(ab,ac,ad)local ae=1;while ae<=#ac do local af=ac[ae]ae=ae+1;ad[af]=false;local ag=Q[af]local ah,ai,aj=ag.needed,a7[af],a8[af]if ai>ah then return false end;if ai+aj<ah then return false end;if aj>0 then if ai==ah then for ak,al in ipairs(ag.vars)do if W[al]==nil then if not N(al,0,ab,ac,ad)then return false end end end elseif ai+aj==ah then for ak,al in ipairs(ag.vars)do if W[al]==nil then if not N(al,1,ab,ac,ad)then return false end end end end else if ai~=ah then return false end end end;return true end;local function X()local ab,ac=-1;for ad=1,P do if W[ad]==nil then local ae=V[ad]if ae>ab then ab=ae;ac=ad end end end;return ac end;local function Y(ab)local ac=X()if not ac then a9=a9+1;local ad=0;for ae=1,P do if W[ae]==1 then ad=ad+1 end end;local ae=1;if not a.UseMineBudget then ae=G[ad]or 1;aa=aa+ae end;local af=I.solutionData;af.ways[ad]=(af.ways[ad]or 0)+1;for ag=1,P do if W[ag]==1 then af.hits[ag][ad]=(af.hits[ag][ad]or 0)+1 end end;return end;do local ad=#ab;local ae,af=z()if N(ac,0,ab,ae,af)and S(ab,ae,af)then Y(ab)end;A(ae,af)R(ab,ad)end;do local ad=#ab;local ae,af=z()if N(ac,1,ab,ae,af)and S(ab,ae,af)then Y(ab)end;A(ae,af)R(ab,ad)end end;local ab,ac,ad={},{},{}for ae=1,#Q do M(ac,ad,ae)end;if S(ab,ac,ad)then Y(ab)end;if not a.UseMineBudget and a9>0 then for ae,af in ipairs(I.orderedVars)do local ag=v[af]local ah=0;local ai=I.solutionData.hits[ae]for aj,ak in pairs(ai)do local al=G[aj]or 1;ah=ah+ak*al end;local aj=ah/aa;if aj<0 then aj=0 end;if aj>1 then aj=1 end;ag.probability=aj;if aj<1e-6 and ag.predicted~="safe"then ag.predicted="safe"q=true elseif aj>0.999999 and ag.predicted~="mine"then ag.predicted="mine"q=true end end end end end end;if a.UseMineBudget then local H={}for I,J in ipairs(F)do if J.solutionData then local K={}local O=0;for P,Q in pairs(J.solutionData.ways)do if P>O then O=P end end;for P=0,O do local Q=J.solutionData.ways[P]K[P+1]=Q and Q>0 and math.log(Q)or e end;local P={}for Q,T in pairs(J.solutionData.hits)do P[Q]={}for U=0,O do local V=T[U]P[Q][U+1]=V and V>0 and math.log(V)or e end end;table.insert(H,{kind="cluster",logWays=K,logHits=P,orderedVars=J.orderedVars})end end;local I=#C;if I>0 then local J={}local K=math.min(I,t)for O=0,K do J[O+1]=l(I,O)end;table.insert(H,{kind="free",logWays=J,count=I,tiles=C})end;local J=t;local K=#H;if K>0 then local O={}O[0]={}for P=0,J do O[0][P]=P==0 and 0 or e end;for P=1,K do O[P]=m(O[P-1],H[P].logWays,J)end;local P={}P[K+1]={}for Q=0,J do P[K+1][Q]=Q==0 and 0 or e end;for Q=K,1,-1 do P[Q]=m(P[Q+1],H[Q].logWays,J)end;local Q=O[K][J]if Q~=e then for T=1,K do local U=H[T]local V={}for W=0,J do V[W]=e end;for W=0,J do local a7=O[T-1][W]if a7~=e then for a8=0,J-W do local a9=P[T+1][a8]if a9~=e then V[W+a8]=j(V[W+a8],a7+a9)end end end end;if U.kind=="cluster"then for W,a7 in ipairs(U.orderedVars)do local a8=v[a7]local a9=U.logHits[W]local aa=r(a9,V,J,Q)a8.probability=aa;if aa<1e-6 and a8.predicted~="safe"then a8.predicted="safe"q=true elseif aa>0.999999 and a8.predicted~="mine"then a8.predicted="mine"q=true end end elseif U.kind=="free"then local W=e;for a7=1,math.min(U.count,J)do local a8=U.logWays[a7+1]local a9=V[J-a7]if a8~=e and a9~=e then W=j(W,math.log(a7)+a8+a9)end end;local a7=0;if W~=e then a7=math.exp(W-Q-math.log(U.count))end;for a8,a9 in ipairs(U.tiles)do a9.probability=a7;if a7<1e-6 then a9.predicted="safe"q=true elseif a7>0.999999 then a9.predicted="mine"q=true end end end end end end end;n._LastTankSystem={unknownMap=u,unknownList=v,equations=w,varToEqIndex=D}return q end;local q={}function q.LogicLoop()print"[Matcha] Logic Brain Started"local function am()local s=game:GetService"Workspace"local t=s:FindFirstChild(a.FlagName)if t then return t:FindFirstChild(a.PartsName)end;return nil end;local s=am()local t=0;local u=0;local v=0;while getgenv().MS_RUN do if not s or not s.Parent then s=am()end;if s then local w=false;t=t+1;v=v+1;if v>10 then v=1 end;if t>=5 then t=0;local C=d.SafeGet(s,"GetChildren")if C then local D=C(s)if#D~=u then u=#D;for E,F in ipairs(D)do local G=d.SafeGet(F,"Position")local H=i.GetGridCoordinates(G)if H and not i.Map[H]then i.RegisterTile(F)w=true end end end end end;for C=#i.Tiles,1,-1 do local D=i.Tiles[C]if not D.part or not D.part.Parent then g.RemoveMarker(D.part)i.Map[D.gridX.."|"..D.gridZ]=nil;table.remove(i.Tiles,C)w=true else local E=D.type=="unknown"or v==1;if E then local F,G=i.AnalyzeTilePart(D.part)if F~="deleted"and(F~=D.type or G~=D.number)then D.type=F;D.number=G;D.predicted=false;D.probability=nil;w=true end end end end;if w then for C=1,10 do if not n.RunTrivial()then break end end;if n.RunTank()then n.RunTrivial()end end;i.BestMove=nil;if a.RecommendBestMove then local C=n.PickBestMove()i.BestMove=C end;local function an(C)if C.type~="unknown"then return"none",nil,nil end;if C.predicted=="mine"then return"pmine",a.Colors.PredictedMine,nil elseif C.predicted=="safe"then return"psafe",a.Colors.PredictedSafe,nil elseif C.probability then local D=math.floor(C.probability*100+0.5)if D<=0 then D=1 end;if D>=100 then D=99 end;local E="prob:"..D;local F=b[D]local G=c[D]return E,F,G end;return"none",nil,nil end;for C,D in ipairs(i.Tiles)do local E,F,G=an(D)if E~=D.visKey then D.visKey=E;if E=="none"then g.RemoveMarker(D.part)else g.UpdateMarker(D.part,F,G,D.storedPos)end end end end;d.Wait(a.Delays.Logic)end end;function q.RenderLoop()print"[Matcha] Render Loop Started"local s=workspace.CurrentCamera;g.InitBestMarker()local t=Vector2.new;local u=d.Clamp;local v=d.CalculateDistance;while getgenv().MS_RUN do local w=d.SafeGet(s,"Position")or Vector3.new(0,0,0)local C=0;for D,E in pairs(g.ActiveMarkers)do local F=E.storedPos;local G=false;local H,I=0,0;local J=0;local K=false;if F then local O,P=WorldToScreen(F)if P or O and not P then if O then local Q=v(F,w)if Q<1 then Q=1 end;J=u(800/Q,10,100)H=O.X or O.x or 0;I=O.Y or O.y or 0;G=true;C=C+1;if E.hasText then K=true end end end end;if G~=E._lastVisible then E.box.Visible=G;E._lastVisible=G end;if G then if J~=E._lastSize or H~=E._lastSX or I~=E._lastSY then E.box.Size=t(J,J)E.box.Position=t(H-J/2,I-J/2)E._lastSize=J;E._lastSX=H;E._lastSY=I end;if K~=E._lastTextVisible then E.text.Visible=K;E._lastTextVisible=K end;if K then E.text.Position=t(H,I-8)end else if E._lastTextVisible then E.text.Visible=false;E._lastTextVisible=false end end end;local D=i.BestMove;local E=false;local F,G=0,0;if D then local H=D.storedPos;if H then local I;local J;I,J=WorldToScreen(H)if I then F=I.X or I.x or 0;G=I.Y or I.y or 0;E=true;C=C+1 end end end;if E~=g.Best._lastVisible then g.Best.ring.Visible=E;g.Best.text.Visible=E;g.Best._lastVisible=E end;if E then if F~=g.Best._lastSX or G~=g.Best._lastSY then g.Best.ring.Position=t(F,G)g.Best.text.Position=t(F,G-28)g.Best._lastSX=F;g.Best._lastSY=G end end;if C==0 then d.Wait(0.1)else d.Wait(a.Delays.Render)end end;g.ClearAll()end;spawn(q.LogicLoop)spawn(q.RenderLoop)
